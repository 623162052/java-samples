多线程  
进程：任务  
任务并发执行是一个宏观概念，微观上是串行的。  
进程的调度是有 OS 负责的（有的系统为独占式，有的系统为共享式，根据重要性，进程有优先级）。  
  
由 OS 将时间分为若干个时间片。  
JAVA 在语言级支持多线程。  
分配时间的仍然是 OS
只有等到所有的线程全部结束之后，进程才退出。 

  
进程的休眠：Thread sleep(1000);//括号中以毫秒为单位 
当main()运行完毕，即使在结束时时间片还没有用完，CPU 也放弃此时间片，继续运行其他程序。 
Try{Thread.sleep(1000);} 
Catch(Exception e){e.printStackTrace(e);} 
T1.join()表示运行线程放弃执行权，进入阻塞状态。 
当t1 结束时，main()可以重新进入运行状态。 
T1.join 实际上是把并发的线程编程并行运行。 
线程的优先级：1-10，越大优先级越高，优先级越高被OS 选中的可能性就越大。（不建议使用，因为不 
同操作系统的优先级并不相同，使得程序不具备跨平台性，这种优先级只是粗略地划分）。 
注：程序的跨平台性：除了能够运行，还必须保证运行的结果。 

一个使用yield()就马上交出执行权，回到可运行状态，等待 OS 的再次调用。 

下午： 
程序员需要关注的线程同步和互斥的问题。 
多线程的并发一般不是程序员决定，而是由容器决定。 
多线程出现故障的原因： 
两个线程同时访问一个数据资源（临界资源），形成数据发生不一致和不完整。  
数据的不一致往往是因为一个线程中的两个关联的操作只完成了一步。  
  
避免以上的问题可采用对数据进行加锁的方法  
每个对象除了属性和方法，都有一个monitor（互斥锁标记），用来将这个对象交给一个线程，只有拿到 
monitor 的线程才能够访问这个对象。  
Synchronized:这个修饰词可以用来修饰方法和代码块  
  
Object obj;  
Obj.setValue(123);  
Synchronized 用来修饰方法，表示当某个线程调用这个方法之后，其他的事件不能再调用这个方法。只 
有拿到 obj标记的线程才能够执行代码块。  
注意：Synchronized 一定使用在一个方法中。  
锁标记是对象的概念，加锁是对对象加锁，目的是在线程之间进行协调。  
加锁时应考虑锁哪个对像?锁哪段代码?锁包含同步变量的类的对像.  
当用 Synchronized修饰某个方法的时候，表示该方法都对当前对象加锁。  
给方法加 Synchronized 和用 Synchronized 修饰对象的效果是一致的。  
  
一个线程可以拿到多个锁标记，一个对象最多只能将monitor 给一个线程。  
Synchronized 是以牺牲程序运行的效率为代价的，因此应该尽量控制互斥代码块的范围。  
  
方法的 Synchronized特性本身不会被继承，只能覆盖。  
  
线程因为未拿到锁标记而发生的阻塞不同于前面五个基本状态中的阻塞，称为锁池。  
每个对象都有自己的一个锁池的空间，用于放置等待运行的线程。  

corejava                                                                    20 

----------------------- Page 21-----------------------

这些线程中哪个线程拿到锁标记由系统决定。  
  
锁标记如果过多，就会出现线程等待其他线程释放锁标记，而又都不释放自己的锁标记供其他线程运行 
的状况。就是死锁。  
死锁的问题通过线程间的通信的方式进行解决。  
线程间通信机制实际上也就是协调机制。  
线程间通信使用的空间称之为对象的等待队列，则个队列也是属于对象的空间的。  
Object 类中又一个 wait()，在运行状态中，线程调用 wait()，此时表示着线程将释放自己所有的锁标 
记，同时进入这个对象的等待队列。  
等待队列的状态也是阻塞状态，只不过线程释放自己的锁标记。  
Notify()  
如果一个线程调用对象的 notify()，就是通知对象等待队列的一个线程出列。进入锁池。如果使用 
notifyall()则通知等待队列中所有的线程出列。  
  
注意：只能对加锁的资源进行 wait()和 notify()。  
  
释放锁标记只有在 Synchronized代码结束或者调用 wait()。  
注意锁标记是自己不会自动释放，必须有通知。  
注意在程序中判定一个条件是否成立时要注意使用 WHILE 要比使用 IF 要严密。  
WHILE 会放置程序饶过判断条件而造成越界。  
补充知识：  
suspend（）是将一个运行时状态进入阻塞状态（注意不释放锁标记）。恢复状态的时候用 resume()。Stop() 
指释放全部。  
这几个方法上都有 Deprecated 标志，说明这个方法不推荐使用。  
  
一般来说，主方法 main()结束的时候线程结束，可是也可能出现需要中断线程的情况。对于多线程一般 
每个线程都是一个循环，如果中断线程我们必须想办法使其退出。  
  
如果主方法 main()想结束阻塞中的线程（比如 sleep 或 wait）  
那么我们可以从其他进程对线程对象调用 interrupt()。用于对阻塞（或锁池）会抛出例外 Interrupted  
Exception。  
这个例外会使线程中断并执行 catch 中代码。  
  
多 线 程 中 的 重 点 ： 实 现 多 线 程 的 两 种 方 式 ， Synchronized, 以 及 生 产 者 和 消 费 者 问 题 
 （ProducerConsumer.java 文件）。  
  
练习：  
① 存车位的停开车的次序输出问题；  
② 写两个线程，一个线程打印 1-52，另一个线程答应字母 A-Z。打印顺序为 12A34B56C……5152Z。通 
   过使用线程之间的通信协调关系。  
注：分别给两个对象构造一个对象 o，数字每打印两个或字母每打印一个就执行o.wait()。在o.wait()之 
前不要忘了写 o.notify()。 

补充说明：通过 Synchronized，可知 Vector 较 ArrayList 方法的区别就是 Vector 所有的方法都有 
Synchronized。所以 Vector 更为安全。  
同样：Hashtable 较 HashMap 也是如此。 