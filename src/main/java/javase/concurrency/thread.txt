线程状态：
	新建状态			：线程对象已经被创建，但是还没有被启动时的状态
	就绪状态				：调用start()方法后等待操作系统分配运行资源
	运行状态				：运行状态			
	等待、阻塞、睡眠状态	：当以下事件发生时,线程进入非运行态。  
							①suspend()方法被调用;  
							②sleep()方法被调用;  
							③线程使用wait()来等待条件变量;  
							④线程处于I/O等待
							|终端用户的请求
							|父进程请求
							|负荷调节的需要
							|操作系统的需要
	死亡态				：当run()方法返回,或别的线程调用stop()方法,线程进入死亡态 
	

--------------------------------
线程优先级：
	线程的优先级用数字来表示，范围从1到10，一个线程的缺省优先级是5 
		Thread.MIN_PRIORITY = 1
		Thread.MAX_PRIORITY = 10
		Thread.NORM_PRIORITY = 5
		
		int getPriority()方法获得线程对象的优先级
setPriority(int newPriority)方法设置优先级
Java提供一个线程调度器来监控程序中启动后进入就绪状态的所有线程。线程调度器按照线程的优先级决定应调度哪些线程来执行
多数线程的调度是抢先式的。即如果在当前线程执行过程中，一个更高优先级的线程进入可运行状态,则这个线程立即被调度执行.

-------------------------------------
使用资源的时候给它上把 “锁”
JAVA通过synchronized实现锁
		Java中的多线程使用 synchronized关键字实现同步。为了避免线程中使用共享资源的冲突，当线程进入 synchronized的共享对象时，将为共享对象加上锁,阻止其他的线程进入该共享对象。

需要明确的问题：

  synchronized关键字可以作为函数的修饰符，也可作为函数内的语句，也就是平时说的同步方法和同步语句块。如果再细的分类，synchronized可作用于instance变量、object reference(对象引用)、static函数和class literals(类名称字面常量)身上。
  无论synchronized关键字加在方法上还是对象上，它取得的锁都是对象，而不是把一段代码或函数当作锁――而且同步方法很可能还会被其他线程的对象访问。
  每个对象只有一个锁(lock)与之相关联。
  实现同步是要很大的系统开销作为代价的，甚至可能造成死锁，所以尽量避免无谓的同步控制
  
---------------------------------------------
死锁：
因为线程可以阻塞，并且对象可以具有同步控制方法，用以防止别的线程在锁还没有释放的时候就访问这个对象。
 所以就可能出现这种情况：某个线程在等待另一个线程，而后者又在等待别的线程，这样一直下去，直到这个链条上的线程又在等待第一个线程的释放锁。
 你将得到一个线程之间相互等待的连续循环，没有哪个线程能继续。这称之为“死锁”（deadlock）。
 
 死锁的四个必要条件：
互斥条件：一个资源每次只能被一个进程使用。
请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。
不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺。
循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。 
 
  