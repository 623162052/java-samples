 并发线程：
	三个多线程包：
		java.util.concurrent    包含了常用的多线程工具，是新的多线程工具的主体。 
		java.util.concurrent.atomic    包含了不用加锁情况下就能改变值的原子变量。
		java.util.concurrent.locks    包含锁定的工具。 
		
	Executor接口：
		替代了Thread类，他可以创建定量的、动态的以及周期性的线程池。
	ExecutorService接口：
		线程池，用来存放线程来节省创建和销毁资源的消耗。
		
	Callable和Future接口：
		Callable是类似于Runnable的接口，实现Callable接口的类和实现Runnable的类都是可被其它线程执行的任务。Callable和Runnable有几点不同：
			Callable规定的方法是call()，而Runnable规定的方法是run(). 
			Callable的任务执行后可返回值，而Runnable的任务是不能返回值的。 
			call()方法可抛出异常，而run()方法是不能抛出异常的。 
		运行Callable任务可拿到一个Future对象，通过Future对象可了解任务执行情况，可取消任务的执行，还可获取任务执行的结果。


一个进程可以包含很多个线程
线程之间用管道流进行通信
主函数main也是个线程，线程中可以有其他子线程
只有当所有子线程结束后，主线程才会结束

锁定的方法，块只能被一个线程使用[不建议对方法使用]【加载run()上就把并线转变成串行】


多线程：
	进程与线程：
		进程：同一个操作系统中执行的一个子程序，包含了三部分虚拟CPU、代码、数据
		多进程：同一个操作系统中执行的多个并行的子程序。可以提高cpu的使用率
		线程：在同一个进程当中执行的子程序流
		多线程：同一个进程当中并发执行的多个子程序流。可以提高cpu的使用率
		进程与线程的区别：
			进程有独立的进程空间，进程中的数据存放空间（堆空间和栈空间）是独立的。
			线程的堆空间是共享的，栈空间是独立的，线程消耗的资源也比进程小，相互之间可以影响的。
		java中如何调进程：
			调用本地程序的两个类
				Runtime
					Runtime.getRuntime.exec(...);	//执行一个程序
						其返回值就是Process类型
				Process		
		注意：
			只有运行状态的线程才有机会执行代码，主线程的中止不会影响其他的正在运行中的线程，主线程中止也就是main()方法退出了。只有进程中的所有线程都中止时，进程（JVM进程）才会退出，只要有线程没有中止，进程就不会退出。
			操作系统决定线程是否有优先级，独占式的操作系统中系统会有优先级的概念，共享式的操作系统则不会有优先级的。
			在线程的内部，程序依然顺序执行
			
			线程的优先级：1-10，越大优先级越高，优先级越高被 OS选中的可能性就越大。 （不建议使用，因为不
同操作系统的优先级并不相同，使得程序不具备跨平台性，这种优先级只是粗略地划分） 。
	
---------------------------------------------------------------			
	Thread中的一些方法：
		currentThread() 
	          	返回对当前正在执行的线程对象的引用(实现接口方式时使用)
		sleep(long millis) 
          		在指定的毫秒数内让当前正在执行的线程休眠(暂停执行)。
			本线程不会去抢，除非sleep结束。
			多个线程之间都会去抢执行权限，不会考虑优先级。
		yield() 
          		暂停当前正在执行的线程对象，并执行其他线程。
          		只给本类或者优先级大于本类优先级的线程去抢。
          	join() 
          		等待该线程终止。	
          		放在start()前面则没有用处。
          	setDaemon(boolean on) 
          		将该线程标记为守护线程，守护线程需要依赖其他线程，会在虚拟机停止的时候停止。
		          		
	线程的生命周期：
		1）初始状态：此时线程只是处于JVM进程中，只是创建了一个线程对象，并没有真正开始运行。
		2）可动行状态：调用线程对象的start()方法，此时线程才真正的被创建，进入可运行状态，等待CPU的调度。“万事俱备，只欠CPU”。
		3）运行状态：正在运行的线程，此时它拥有CPU的执行权。
		4）阻塞状态：运行状态中的线程，如果正在等待用户输入或调用了sleep()和join()等方法都会导致线程进入阻塞状态，注意从阻塞状态出来的线程不一定马上回到运行状态，而是重新回到可运行状态，等待CPU的再次调度。
		5）等待队列状态：一个线程调用一个对象的wait()会自动放弃该对象的锁标记，进入等待队列状态，只有当有另外一线程调用临界资源的notify()或notifyAll()方法，建议多使用notifyAll()，才会将等待队列中的线程释放，此线程进入锁池状态。
		6）锁池状态：每个对象都有互斥锁标记，以防止对临界资源的访问造成数据的不一致，和数据的不完整性。一个线程拥有一个对象的锁标记后，另一线程想访问该对象，必须在锁池中等待。由系统决定哪个线程拿到锁标记并运行。注意从锁池状态出来的线程不是马上回到运行状态，而是重新回到可运行状态，等待CPU的再次调度。
		7）终止状态：一个线程运行结束后称为终止状态，一个进程中只有所有的线程退出后才会终止。
		
		
多线程：
	多线程的同步：	
		多线程并发访问同一个对象（临界资源），如果不对线程进行同步控制，破坏了原子操作(不可再分的操作)，则会造成临界资源(两个线程同时访问的资源)的数据不一致。   

		每一个对象都有一个互斥的锁标记和一个锁池。当线程拥有这个对象的锁标记时才能访问这个资源，没有锁标记便进入锁池，保证在同步代码块中只有一个线程，解决了多线程同步控制的问题。
		
		关键字：synchronized	//线程在同步代码中必须采用串行访问
			synchronized修饰代码块：对括号内的对象object加锁，  只有拿到对象锁标记的线程才能进入该代码块。
	   			public void push(char c){ 
	        			synchronized(object){ 	//object只要是对象就可以，但必须保证是同一对象
	        				……
 	        				同步代码 
	        				……
	        			} 
	   			}
	   			
			synchronized修饰方法：在整个方法范围内对当前对象的加锁，只有拿到对象锁标记的线程才能执行该方法。尽可能的少用
	   			public synchronized void push(char c) {
					……
					同步代码 
					……	
				}
	      			
		一个线程可以同时拥有多个对象的锁标记，锁标记如果过多，就会出现线程等待其他线程释放锁标记，而又都不释放自己的锁标记供其他线程运行的状况，造成死锁。				

		静态方法可以是同步方法：但是它所锁的并不是当前对象，是类对象。
		抽象方法不能是synchronized同步的方法。
		构造方法不能是synchronized同步的方法。
			
		线程因为未拿到锁标记而发生阻塞进入锁池（lock pool）。每个对象都有自己的一个锁池的空间，用于放置等待运行的线程。由系统决定哪个线程拿到锁标记并运行
		
		利用Collections类中的synchronizedXxxx(Xxxx ss)方法可以得到相应集合的线程安全的集合
		
		注意：
			在同步语句块中不能直接操作对象锁正在使用的对象。
			对象与锁一一对应。
			同步依赖对象锁，锁对象相同，同步语句串行，锁对象不同，同步语句并行。
			顺序锁，不要回调，反向打开。
			能不用同步就不用同步，有数据共享冲突时才使用同步。
		
	等待通知机制：
		线程间通信使用的空间称之为对象的等待对列（wait pool），该队列也是属于对象的空间的。
		
		使用Object类中wait()的方法，在运行状态中，线程调用wait()，此时表示线程将释放自己所有的锁标记和CPU的占用，同时进入这个对象的等待池。等待池的状态也是阻塞状态，只不过线程释放自己的锁标记。只有在对该对象加锁的同步代码块里，才能掉用该对象的wait()，表示线程将会释放所有锁标记，进入等待队列，线程将进入等待队列状态。
		
		一个线程进入了一个对对象加锁的同步代码块，并对该对象调用了wait()方法，释放自己拥有的所有锁标记，进入该对象等待队列，另一个线程获得了该对象的锁标记，进入代码块对该对象调用了notify()方法，就会从等待队列里释放出一线程，释放出的这个线程要继续运行就还要进入那个同步代码块，因为得不到要访问代码块对象的锁标记，而进入该对象的锁池，等待锁标记释放。
		
		什么情况下释放锁：
			同类代码执行完毕。
			异常未处理，错误退出。
			调用wait()。
		
		相关方法：
			1) wait()：交出锁和CPU的占用; 
			2) notify()：将从对象的等待池中移走一个任意的线程，并放到锁池中，那里的对象一直在等待，直到可以获得对象的锁标记。 
			3) notifyAll(): 将从等待池中移走所有等待那个对象的线程并放到锁池中，只有锁池中的线程能获取对象的锁标记，锁标记允许线程从上次因调用wait()而中断的地方开始继续运行
			
		注意：
			用notifyAll()取代notify()，因为在调用notify()方法时，是由系统决定释放出哪个线程。
			只能对加锁的资源进行wait()和notify()。
			判断是否进行等待wait()时，用while代替if来进行判断。
			
  