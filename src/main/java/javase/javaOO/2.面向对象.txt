
Java面向对象	
	1.构造方法(Constructor)		
			参数个数少的构造方法可以调用参数多的构造方法，以此来重用代码[this(参数,null)]
			 1.初始化该类的新对象，定义初始值、内存分配等		 
			 2.构造方法名与类同名，没有返回类型修饰
			 3.当一个类至少定义了一个构造方法时，系统不会有默认构造函数。子类构造函数不会自动调用父类的非空构造函数，需要用super调用
			 4.构造方法不能调用普通方法，但普通方法能调用构造方法，构造函数只能被重载，不能被重写，构造方法不能继承，子类构造方法必须调用父类的构造方法[自动或手动]	 
			 5.构造方法只能由new创建对象分配内存时调用。
			 6.若类无构造方法，创建类的对象时，调用缺省的空构造方；如果子类的构造方法中没有显式地调用基类构造方法，则系统默认调用基类无参数的构造方法.
			 7.super调用父类的构造方法要被放在第一行，不存在一个构造函数中既有super（），又有this（），他们都要在第一行，但可以存在多个super.属性或this.属性
					this ：this是一和指向自身对象的引用，也可以用来调用构造方法
					
	2.类和对象 
				类：对事物、逻辑、概念、算法的抽象				引用：保存指向实例的内存地址
				类之间的关系	
						依赖(uses-a)	一个类使用另一个类
						聚合(has-a)		包含
						继承(is-a)	继承
				[创建对象步骤：对象声明、分配内存、赋值(声明时，对象为 null; 此时对象不能使用，需分配内存，否则NullPointerException]
				[类方法，对象方法--类加载时,类方法被分配入口地址; 对象方法是在对象创建时被分配入口地址]
				加载类	---类变量在类加载时分配内存,对象变量在创建对象时分配内存,类变量在程序退出时释放内存; 对象不存在对象变量就不存在了		
			Object类	
					toString()		：返回此对象的字符串表示
					equals()		：判断其他对象是否与此对象相等
					hashCode()		：返回此对象的哈希码值,当对象保存在哈希表中时，该方法才有用
					finalize()		：当垃圾回收器确定不存在此对象的更多引用时，由对象的垃圾回收器调用此方法
					clone()			：创建并返回次对象的副本
										重写clone方法，可以将访问放大
										克隆完后，两个对象数据完全相同，但地址不同
										类必须事先Cloneable接口才能克隆
										克隆得到相同状态的两个对象，但是equals()方法比较得到false
										克隆相比于拷贝，clone是两个对象，拷贝是一个对象
			
				
	3.类变量与实例变量
				在内存中，所有对象共享一个类变量，而每个对象都有自己独自的实例变量
	4.静态与非静态
				在生命周期内，类相关的静态初始化只执行一次
				静态方法通过类名和对象调用,非静态方法通过对象调用
				静态方法不可以调用非静态方法和属性；非静态方法可以调用静态方法和属性
				静态方法不能调用非静态方法和非静态属性，可以实例化对象调用
			   【静态方法不能被重写】
			   静态方法不需要被实例化就可以调用，只申明没实例化的也可以调用
			   静态只能修饰全局变量和方法，不能修饰局部变量
			   静态方法不能被子类重写，只能被隐藏
	5.类与成员变量的修饰符
			类：		
				public		所有类访问
				default		当前类和当前包的其他类访问
				abstract	没有实例的抽象概念类
				final		不能被继承。不能被扩展、不包含子类[安全，创建固定功能的类][final+static 修饰的才是真正的常量]
				【extends		继承
				implements	接口修饰符】
			成员变量：
				public		所有类访问
				protected	当前类、子类、当前包的其他类
				private		仅可被当前类引用、修改
				static 		引用时前缀可以使用类名、对象名
				final		最终修饰符，定义且应同时初始化  【final修饰的变量需要被初始化】
				volatile	异步控制修饰符，表示多个并发线程共享的变量，使得各线程对该变量的访问保持一致
				transient	与对象序列有关[被transient修饰的不参加序列化]
			成员方法：
				public,private,protected,default  同上
				static		可用类名和对象名调用，在方法体中，只能使用static变量和static方法或访问自己的局部变量[static 修饰的属性方法只与类有关，与对象无关]
				abstract	抽象方法，只有接口没有语句，要在子类中通过重新定义(override)来实现
				final		不能被重写
				throws		通过throws会产生异常，提醒调用者要对相应的可能例外处理，当执行此方法并发生例外时，程序会转入调用者编制的例外处理程序段
			其他：
				clone		对象copy运算符
				super		父类引用符------指向父类的当前对象【方法重写后通过super调用父类的方法】【super和this必须写在构造函数的第一行】[静态方法中不能使用 this 和 super][可以在子类的构造方法中调用父类的构造方法，也可以在子类的方法中调用父类的方法]
				this 		本省引用符------指向当前对象
			final类不能被继承，没有子类，final类中的方法默认是final的。 
			final方法不能被子类的方法覆盖，但可以被继承。 
			final成员变量表示常量，只能被赋值一次，赋值后值不再改变。 
			final不能用于修饰构造方法
			final是最终修饰符，可以修饰类、属性和方法。它几乎和abstract是完全相反的概念:

*********************************************************************************************************×××××××××××××××××××××××××××××××××××××××××××××××××
	6.封装	[private]		
			1.封装的作用：增加数据访问限制，增强代码可维护性
			2.封装的关键：绝对不能让类中的方法直接访问其他类的实例域，程序通过对象的方法与对象数据进行交互，封装给予了对象"黑盒"的特性
			3.封装的实现：
						1、修改属性的修饰来限制对属性的访问，使用protected修饰类
						2、为属性创建赋值（set）和取值（get）方法，来控制属性访问权限【可以通过判断条件限制】	
						3、接口也是一种封装实现[接口隔离]
						4、使用内部类
						
	7.继承	[extends]		
			1.作用：增加代码复用
			2.存在继承时，子类实例化过程：
						->加载父类：初始化父类静态属性和静态块
						->加载子类：初始化子类静态属性和静态块
						->对象预开空间，所有全局属性都给默认值
						->初始化父类非静态属性和语句块
						->父类构造函数
						->初始化子类非静态属性和语句块
						->子类构造方法
						
			3.注意点 	常见的有属性继承，属性隐藏，方法继承，方法覆盖，方法重载等技术
						在父类中只定义一些通用的属性与方法;子类自动继承父类的属性和方法，子类中可以定义特定的属性和方法
						所有的Java类都直接或间接地继承了java.lang.Object
						申明并创建子类对象时，先new父类对象，再new子类对象，且两个对象捆绑在一起，且申明的引用变量指向子类对象，子类没有的转而对父类对象操作，子类有的直接对子类象操作
						
						
					继承设计的技巧：
					1.	将公共操作和域放在超类
					2.	不要使用受保护的域
					3.	使用继承实现"is a"关系
					4.	除非所有继承的方法都有意义，否则不要使用继承
					5.	在覆盖方法时，不要改变预期行为
					6.	使用多肽，而非instanceof
					7.	不要过多的使用反射

	8.多态
				不同声明类型的对象调用相同名称的成员函数，执行不同的代码叫多态
				一种对象，多种形态[声明类型不同，但对象类型相同]
				
				运行时多态：方法重写  可以根据【父类、子类、接口】声明的对象在运行时动态的选择调用方法【属性没有多态，属性看声明类型】
				编译时多态：方法重载		
				
				1.增加代码的抽象性，增加代码的可扩展性和可维护性
				2.方法重写Override和重载Overload
					方法重载(overload)[编译时多态]
						方法名相同
						参数个数或类型或顺序不同
						可改变方法返回类型
						可改变访问修饰符
						方法在同一个类或者子类中被重载
					方法重写[运行时多态][后期绑定]
						参数类型、个数、顺序、返回类型相同
						访问修饰符与父类相同或更开放
						不能抛出更多异常
						[静态方法不能被重写]
						
						方法重写后，通过super关键字调用父类的方法，也可以通过声明类型动态调用父类方法					
				4.举例	
						Human human = new Male();
						human只能调用Human有的方法【Human限定了human的范围】（实际是调用子类Male的方法），不能调用父类没有但子类有的方法
						如果human想调用父类没有但子类有的方法，可以强转 ：((Male)human).method();【.的优先级大于括号，所以.之前要加括号】
***********************************************************************************************************						
						
	9.抽象方法、抽象类和接口		[为多态服务]
				抽象方法
						通常描述各个子类都拥有但又彼此不相同的方法
				抽象类 	abstract
						【抽象类作为基础框架，被继承】
						抽象类和普通类相同  除了不能被实例化
						【被子类继承的抽象父类的保护抽象方法可以被父类的其他方法调用】
						
						
				接口 	interface[为多态服务][面向抽象编程]
				
					低耦合作用：把使用标准和实现标准分开，使得标准的制定者和实现者解除偶合关系，具有极强的可移植性
				例：sun公司提供一套访问数据库的接口（标准），java程序员访问数据库时针对数据库接口编程。接口由各个数据库厂商负责实现。
		     
			 
			 static：
				在类中,用static声明的成员变量为静态成员变量,它为该类的公用变量,
				在第一次使用时被初始化,对于该类的所有对象来说,static成员变量只有一份.

				任何一个对象都可以访问static类型的值,访问时访问的是同一块内存
				即使没有对象也可以访问这个值,用类名加上点访问,如System.out

				字符串也在data segment里,可以看成一对象.

				静态的值能计数用

				动态方法是针对某一个对象来调用的,静态的方法不会针对某一个对象来调用

				用static声明的方法为静态方法,在调用该方法时,不会将对象的引用传递给它,所以在static方法中不可访问非static的成员.
				静态方法不再是针对于某个对象调用,所以不能访问非静态成员.
				可以写成  类名.静态方法名

********************************************************************************************************
面向对象设计：
		对于开发者，现有子类，然后抽出共同特性，然后有父类。先设计类，再往每个类中添加方法

	类的设计技巧
		1.一定将数据申明为私有【不要破坏封装性】
		2.一定要对数据初始化
		3.不要在类中使用过多的基本数据类型【用其他的类代替多个相关的基本数据类型，这样易于理解和修改】
		4.不是所有的域都需要地理的域访问器和更改器
		5.使用标准格式进行类的定义
		6.将职责过多的类进行分解
		7.类名和方法名要能够体现它们的职责	
			 
***********************************************
紧封装
		紧封装作用：在实现代码中进行修改，而不中断使用该代码的其他人的代码能力
低耦合	
		耦合：一个类了解另一个类的程度。
		低耦合：如果类A对类B的了解仅限于类B通过其接口公开的信息，则称类A和类B是低耦合的。类与类之间的关系尽量降低
		高耦合：如果类A依赖类B的某些部分，而这些部分不是类B的接口部分，那两个类之间高耦合		
		高耦合危害：如果类A依赖类B的非接口部分，类B修改了非接口部分的内容就会导致类A中断，所以类与类之间的关系应尽量通过接口联系
		低耦合作用：提高程序的可扩展性	
高内聚
		内聚：一个类具有单一的、明确目标的程度
		高内聚作用：与低内聚相比，高内聚的类更容易维护（很少发生更改），目标明确的类可复用性高于其他类
***********************************************
	接口编程的原则
		尽量针对接口编程（能用接口就尽量用接口）
		接口隔离原则（用若干个小接口取代一个大接口）
						     接口隔离，与封装性有关。一个对象都有多个方面，可以只展示其中几个方面，其他的都隐藏。因此可以看为“更高层次的封装”，把一个大接口做成若干个小接口。
		通过接口制定标准（最重要的作用）
			接口：制定标准。
			接口的调用者：使用标准。
			接口的实现类：实现标准。
					接口中创建对象，则该对象为常量（static+final），永远指向那个堆，不能改变指向；但堆中的值可以改变
					
					接口 = 接口中的变量都是常量【默认加 public+static+final 】+ 接口中的方法都是抽象方法【默认加 public+abstract 】					
					接口中方法可以被重载
					功能：帮助实现类似于类的多重继承
					implements 实现接口，表示该类实现接口中的抽象方法，一个类可以实现多个接口			
					【父类和所有接口可以作为声明类型】			
					接口可以继承其它的接口，并添加新的属性(常量)和抽象方法
					通过接口可以了解对象的交互界面，而不需了解对象所对应的类			
					【接口相当于电脑的PCI插槽，硬件的内部结构相当于各个类的内部结构】
				面向接口编程 开发系统时，主体构架使用接口，接口构成系统的骨架，这样就可以通过更换接口的实现类来更换系统的实现
				