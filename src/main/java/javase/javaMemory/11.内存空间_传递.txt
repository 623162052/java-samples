JAVA内存空间			程序入口-->运行主函数，则主函数被挂到栈					然后方法加载到栈，引用变量也在栈					创建的对象放在堆（特殊情况除外）		寄存器：	最快存储区，编译器根据需求分配，程序无法控制		堆：		(不能共享)存放所有new出来的对象[除了String][对象的地址和数据]						[堆中的对象的由垃圾回收器负责回收，大小和生命周期不需要确定，具有很大的灵活性]		栈：		(可以共享)[基本数据类型的变量和数据]和[对象的引用]						[栈中的数据大小和生命周期是可以确定的，当没有引用指向数据时，这个数据就会消失]		常量池：	(可以共享)存放字符串常量和基本类型常量（public static final）						[对于字符串：其对象的引用都是存储在栈中，						如果是编译期已经创建好(直接用双引号定义的)的就存储在常量池中，						如果是运行期（new出来的）才能确定的就存储在堆中】		静态域：	(可以共享)存放静态成员（static定义的)		非RAM存储：	硬盘等永久存放空间 						1.String a = new String("abc");    产生两个对象 ，一个放在堆，一个放在常量池放“abc”			栈     堆      	  常量池			a----->地址------>"abc"						2.StringBuilder varOne = new StringBuilder("abc");			栈     			堆        常量池			varOne	->		地址----->"abc"					3.String a = "abc";			栈-----常量池			a------>"abc"						4.int a = 3;  a和3都放在栈					5.Object[] obj=new Object[5];			此时数组中元素没被实例化，实例化后，数组中装的是对象的引用，每个数组元素指向堆中的一个对象				6.int[] array=new int[5];			此数组放在堆中		7.int[] array={1,2,3};			声明数组对象的同时分配内存空间，并为数组元素赋值				8.String str = "aa" + "bb" +"cc";				程序编译期间会直接得到str="aabbcc"，不会得到其他对象，这是编译器的优化		传递			传递对象的引用变量的副本		[Java中所有的传递都是传值]	【地址也是一个值】			对象在参数传递时,只使用值传递				传递基本变量：值传递		传递对象引用变量：			将对象变量传递到方法时，传递的是对象引用			引用变量传递时，根本没有传递实际的引用变量，而是该引用变量的一个副本			调用方法和被调用方法都具有引用完全相同的副本，二者都将引用堆上完全相同的对象			如果被调用方法修改该对象，则调用方法最初变量引用的对象也会被修改			[改地址不影响，改地址里的值有影响]					基本类型传递：只传递值				String和封装类的引用变量传递值				其他对象传地址				引用变量传副本【两个栈区的两个引用变量指向堆中的同一个对象】			参数传递时，简单类型进行值转递(参数进行传递时都会先去栈中生成一个副本的，使用结束后释放)							